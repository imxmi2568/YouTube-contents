# 永続的な重み付き左偏ヒープの実装

## 背景
左偏ヒープ（Leftist Heap）は、マージ（結合）操作を非常に効率的（$O(\log n)$）に行えるプライオリティ・キューの一種です。関数型言語では、一度作ったデータを書き換えない永続的（Persistent）なデータ構造として実装するのに非常に適しています。今回は、各ノードの重み（そのノード以下の全ノード数）を利用して木のバランスを保つ**重み付き左偏ヒープ**を実装してください。

## 要件
以下のステップに従って、モジュールまたは一連の関数を実装してください。
### ステップ1. データ構造の定義 (5分)
整数を格納するヒープの型 `heap` を定義してください。ヒープは空（`Empty`）であるか、ノード（`Node`）であるかのいずれかです。各ノードには以下の情報を持たせてください。
1. 重み（`int`）：そのノードを根とするサブツリーに含まれる全ノードの合計数。
2. 値（`int`）：格納する値（最小ヒープとするため、根が最小値を持つ）。
3. 左の子（`heap`）。
4. 右の子（`heap`）。
### ステップ2：補助関数の実装 (5分)
ヒープの重みを安全に取得する `weight : heap -> int` 関数を作成してください。`Empty` の場合は `0`、`Node` の場合は保持している重みを返します。
### ステップ3：マージ操作の実装 (25分)
本問題の核心です。2つのヒープを結合する `merge : heap -> heap -> heap` を実装してください。
1. 両方の根を比較し、値が小さい方を新しい根にします。
2. 小さい方の右の子ともう一方のヒープを再帰的に `merge` します。
3. マージ後の左の子と右の子の重みを比較します。
4. 左の子の重み $\ge$ 右の子の重みになるように、必要であれば左右を入れ替えます。
5. 新しい重みを計算（1 + 左の重み + 右の重み）してノードを構築します。
### ステップ4：基本操作の実装 (15分)
`merge` を利用して、以下の関数を実装してください。
- `insert : int -> heap -> heap` : 値を1つ挿入する。
- `find_min : heap -> int` : 最小値（根の値）を返す（空の場合は例外を投げる）。
- `delete_min : heap -> heap` : 最小値を取り除いた新しいヒープを返す（空の場合は例外を投げる）。
### ステップ5：検証 (10分)
任意のリスト（例：`[5; 2; 8; 1]`）から順に `insert` し、`find_min` と `delete_min` を繰り返すことで、昇順に値が取り出せることを確認してください。