# 永続的な重み付き左偏ヒープの実装

## 背景
左偏ヒープ（Leftist Heap）は、マージ（結合）操作を非常に効率的（$O(\log n)$）に行えるプライオリティ・キューの一種です。関数型言語では、一度作ったデータを書き換えない永続的（Persistent）なデータ構造として実装するのに非常に適しています。今回は、各ノードの重み（そのノード以下の全ノード数）を利用して木のバランスを保つ**重み付き左偏ヒープ**を実装してください。

## 要件
以下のステップに従って、モジュールまたは一連の関数を実装してください。
### ステップ1. データ構造の定義 (5分)
整数を格納するヒープの型 `heap` を定義してください。ヒープは空（`Empty`）であるか、ノード（`Node`）であるかのいずれかです。各ノードには以下の情報を持たせてください。
1. 重み（`int`）：そのノードを根とするサブツリーに含まれる全ノードの合計数。
2. 値（`int`）：格納する値（最小ヒープとするため、根が最小値を持つ）。
3. 左の子（`heap`）。
4. 右の子（`heap`）。
### ステップ2：補助関数の実装 (5分)
ヒープの重みを安全に取得する `weight : heap -> int` 関数を作成してください。`Empty` の場合は `0`、`Node` の場合は保持している重みを返します。
### ステップ3：マージ操作の実装 (25分)
本問題の核心です。2つのヒープを結合する `merge : heap -> heap -> heap` を実装してください。
1. 両方の根を比較し、値が小さい方を新しい根にします。
2. 小さい方の右の子ともう一方のヒープを再帰的に `merge` します。
3. マージ後の左の子と右の子の重みを比較します。
4. 左の子の重み $\ge$ 右の子の重みになるように、必要であれば左右を入れ替えます。
5. 新しい重みを計算（1 + 左の重み + 右の重み）してノードを構築します。
### ステップ4：基本操作の実装 (15分)
`merge` を利用して、以下の関数を実装してください。
- `insert : int -> heap -> heap` : 値を1つ挿入する。
- `find_min : heap -> int` : 最小値（根の値）を返す（空の場合は例外を投げる）。
- `delete_min : heap -> heap` : 最小値を取り除いた新しいヒープを返す（空の場合は例外を投げる）。
### ステップ5：検証 (10分)
任意のリスト（例：`[5; 2; 8; 1]`）から順に `insert` し、`find_min` と `delete_min` を繰り返すことで、昇順に値が取り出せることを確認してください。

## 追加課題案
### 1. 多相的（Polymorphic）な実装への拡張
現在の実装は `int` 専用ですが、任意の型を扱えるように拡張してください。比較関数（Comparator）を引数で受け取る、あるいはファンクタ（OCamlの場合）や型クラス（Haskellの場合）を利用して、文字列やカスタムレコードを格納できるように変更します。
### 2. 計算量の検証とプロパティベーステスト
実装が正しく左偏（Leftist）の性質を維持しているかを検証します。**s-value（右背骨の長さ）と重み（ノード数）** の関係性をチェックする関数を実装してください。任意のランダムなリストをヒープに変換し、空になるまで `delete_min` を繰り返した結果が、元のリストをソートしたものと一致するかを確認する自動テストを作成してください。
### 3. 計算効率の最適化：一括ビルド（$O(n)$）
現在は空のヒープに $n$ 回 `insert` することでリストからヒープを構築していますが、これは $O(n \log n)$ かかります。キューを利用して、隣り合うヒープを順次マージしていくことで、リストから $O(n)$ でヒープを構築する `of_list` 関数を実装してください。
### 4. 永続性の活用：履歴管理機能
データ構造が不変であることを利用して、操作の履歴を保持するラッパーを実装してください。`insert` や `delete_min` を行うたびに過去の `heap` オブジェクトをリスト等に保存し、特定のステップまで状態を巻き戻せる（Undo機能）ようにします。
### 5. 重み付き左偏ヒープ vs ランク（s-value）付き
左偏ヒープ一般的な左偏ヒープは、重みの代わりに右の空ノードまでの最短距離（Rank/s-value）を使用します。今回の重み（ノード数）ベースの実装と、従来のランクベースの実装で、木の形状やマージの回数にどのような違いが出るか、大きなデータセット（例：10万要素）を用いて比較・考察してください。